/*
 *  microcircuit_spec.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

% autorun=true

/*
    Implementation of the multi-layered local cortical network model by

    Potjans, Tobias C. and Diesmann, Markus (2014) The cell-type specific
    cortical microcircuit: relating structure and activity in a full-scale
    spiking network model. Cerebral Cortex. doi:10.1093/cercor/bhs358.

    The script defines and executes the following functions in the given sequence:
    1. CheckParameters
    2. PrepareSimulation
    3. DerivedParameters
    4. CreateNetworkNodes
    5. WritenodeIDsToFile
    6. ConnectNetworkNodes

    Please see the file README.txt for details.

    microcircuit_spec.sli: Version modified for SPAC CPU benchmark
    			   - Number of threads can be set on command line
			   - Model scale can be set on command line
			   - Recording to memory only, can be turned off entirely
			   - Random seed can be set
			   - Total spike count, timers and som more stats reported at end
			   - Entirely self-contained, does not depend on external files
			   - Assumes being run on a single MPI process

    Configuration via colon-separated user arguments, where all arguments are optional

    nest --userargs=threads=T:scale=S:seed=R:record=true/false microcircuit_spec.sli

    e.g.

    nest --userargs=threads=4:scale=0.4:seed=12 microcircuit_spec.sli

    Note: Because NEST uses bitfields of limited size in spike communication, only about
          134 million connections can be handled on a single thread. Therefore, scale
	  must not be larger than 0.4 for a single thread and 0.8 for two threads. If more
	  connections are needed, increase NUM_BITS_LCID in nest_types.h and reduce other
	  NUM_BITS_* correspondingly.

    Note: Expected value for "Total spikes" depends on scale. The table shows results observed
          for different random seed values (one value only for scale 1):

          Scale 0.1:   31562   30572   29754
	  Scale 0.2:   56191   55304   56539
	  Scale 0.4:  111171  110704  108957
	  Scale 1.0:  270416

	  Changing the number of threads for fixed scale will lead to changes in "Total spikes" comparable
	  to the differences observed for different seeds, since random numbers are distributed differently.

	  Compiling with different compilers (specifically C++ standard libraries with different non-uniform
	  random number algorithms) will lead to similar changes in "Total spikes".

	  Different implementations of the exp() or expm1() function in different glibc() or hardware architectures
	  may also lead to different "Total spike" values, see

	      Blanco, W., Lopes, P. H., De S. Souza, A. A., & Mascagni, M. (2020).
	      Non-replicability circumstances in a neural network model with Hodgkin-Huxley-type neurons.
	      Journal of Computational Neuroscience, 48(3), 357â€“363. https://doi.org/10.1007/s10827-020-00748-3

*/


% call like:
% nest --userargs=$scale,$nvp,$randomweights,$tofile hpc_benchmark_extrae.sli

%

% ************************************************************************** %
%                                                                            %
% Parse command line                                                         %
%                                                                            %
% ************************************************************************** %

/n_threads 1 def
/scale 0.1 def
/rng_seed 12345 def
/record true def

/t_sim 1000.0 def
/dt 0.1 def

% By default, record all spikes in simulation, reporting only counts per area at the end
% Set to e.g., /max_rec_spikes 100 def to record at most from 100 neurons per area
/max_rec_spikes 80000 scale mul cvi def

statusdict /userargs get { (=) breakup } Map
{
 arrayload ;
 /val Set /key Set

 mark
 key (threads) eq { /n_threads val cvi def } case
 key (scale) eq { /scale val cvd def } case
 key (seed) eq { /rng_seed val cvi def } case
 key (record) eq { /record val (true) eq def } case
 { /microcircuit_spec (Unknown option: ") key join (") join cvlit raiseerror }
 switchdefault
}
forall



% CheckParameters - This function performs a (non-exhaustive) check of
% parameter dimensions and values.
%
% In particular, the following is checked:
%   - Is the model of type /iaf_psc_exp?
%   - Do dimensions of the given probablity matrix match
%   - Are the numbers/fractions of neurons to record from
%     compatible with the network size
%
/CheckParameters
{
    neuron_model /iaf_psc_exp eq not {
	Rank 0 eq {
           M_WARNING (CheckParameters)
           (Unexpected neuron type: ) neuron_model cvs join
           (. Script is tuned to /iaf_psc_exp neurons.) join
           message
	} if
    } if

    /vm0_type_options <(original) (optimized)> def
    Vm0_type (original) eq not
    {
        Vm0_type (optimized) eq not
        {

           M_WARNING (CheckParameters)
           (') Vm0_type join
           (' is not a valid option, replacing it with ') join
           vm0_type_options 0 get join
           ('; Valid options are ') join
           vm0_type_options 0 get join
           (' and ') join
           vm0_type_options 1 get join
           (') join
           message

           % reset variable to (original)
           /Vm0_type vm0_type_options 0 get def
        } if
    } if

    /n_layers full_scale_n_neurons length def
    /n_pops_per_layer full_scale_n_neurons Dimensions 1 get def

    conn_probs Dimensions 0 get
    n_layers n_pops_per_layer mul
    eq not {
	M_ERROR (CheckParameters)
	(/conn_probs does not contain /nlayers * /n_pops_per_layer rows)
	message raiseerror
    } if

    conn_probs Dimensions 1 get
    n_layers n_pops_per_layer mul
    eq not  {
	M_ERROR (CheckParameters)
	(/conn_probs does not contain /nlayers * /n_pops_per_layer columns)
	message raiseerror
    } if

} def


% PrepareSimulation - Set kernel parameters and RNG seeds based on the
% settings in sim_params.sli.
%
/PrepareSimulation
{
    ResetKernel

    % set global kernel parameters
    <<
       /resolution dt
       /local_num_threads n_threads
       /overwrite_files false
       /rng_seed rng_seed
    >> SetKernelStatus
} def


% DerivedParameters - Compute derived parameters from the ones given
% in network_params.sli.
%
/DerivedParameters
{
    % compute numbers of neurons for the given surface area
    /n_neurons
    full_scale_n_neurons { area mul cvi } [2] Map
    def

    % compute PSC amplitude from PSP amplitude

    model_params using
    % factor for transforming PSP amplitude to PSC amplitude

    /re tau_m tau_syn_ex div def
    /de tau_syn_ex tau_m sub def
    /ri tau_m tau_syn_in div def
    /di tau_syn_in tau_m sub def

    /PSC_e_over_PSP_e
    (((C_m)^(-1)*tau_m*tau_syn_ex/de*(re^(tau_m/de)-re^(tau_syn_ex/de)))^(-1))
    ExecMath def

    /PSC_i_over_PSP_i
    (((C_m)^(-1)*tau_m*tau_syn_in/di*(ri^(tau_m/di)-ri^(tau_syn_in/di)))^(-1))
    ExecMath def
    endusing

    /PSC_e PSC_e_over_PSP_e PSP_e mul def
    /PSC_e_23_4 PSC_e_over_PSP_e PSP_e_23_4 mul def
    /PSP_i PSP_e g mul def
    /PSC_i PSC_i_over_PSP_i PSP_i mul def

    % PSC amplitude for all external input
    /PSC_ext PSC_e_over_PSP_e PSP_ext mul def

    % array of synaptic current amplitudes
    [4 2 4] [PSC_e PSC_i] LayoutArray /PSC_array Set
    PSC_array [0 0 1 0]  PSC_e_23_4 put /PSC_array Set

    % standard deviations of synaptic current amplitudes
    /PSC_sd [PSC_e PSC_i] PSC_rel_sd mul def
    /PSC_th_sd PSC_ext PSC_rel_sd mul def

    % standard deviations of delays
    /delays_sd delays delay_rel_sd mul def
    /delay_th_sd delay_th delay_th_rel_sd mul def

    /n_neurons_rec_spikes
    full_scale_n_neurons { { area mul cvi max_rec_spikes min } Map } Map
    def

} def


% the following variables are created here:
% neuron_nodeIDs
% poisson_nodeIDs
% dc_generator_nodeIDs
% spike_recorder_nodeIDs
% th_neuron_nodeIDs
% th_poisson_nodeID
% th_spike_recorder_nodeID
/CreateNetworkNodes
{
    neuron_model model_params SetDefaults
    % arrays of nodeIDs:
    /neuron_nodeIDs         [n_layers n_pops_per_layer] 0 LayoutArray def
    record { /spike_recorder_nodeIDs [n_layers n_pops_per_layer] 0 LayoutArray def } if
    /poisson_nodeIDs        [n_layers n_pops_per_layer] 0 LayoutArray def
    /dc_generator_nodeIDs   [n_layers n_pops_per_layer] 0 LayoutArray def

    0 1 n_layers 1 sub {
        /layer_index Set

        0 1 n_pops_per_layer 1 sub {
            /population_index Set

	    % create the neurons
	    neuron_model % what model
	    n_neurons layer_index get population_index get % how many
	    Create /population Set

	    % store the NodeCollection
            neuron_nodeIDs [layer_index population_index] % the position
	    population put /neuron_nodeIDs Set

            % initialize membrane potentials
            population {
               Vm0_type (optimized) eq
               {
                   <<
                      /V_m
                      << /normal
                        <<
                          /mean Vm0_mean layer_index get population_index get
                          /std Vm0_std layer_index get population_index get
                        >>
                      >> CreateParameter

                   >>
               }{
                   <<
                      /V_m
                      << /normal << /mean Vm0_mean /std Vm0_std >> >> CreateParameter
                   >>
               } ifelse
               SetStatus
	    } forall

	    record
	    {
            spike_recorder_nodeIDs [layer_index population_index] /spike_recorder <<
	       /record_to /memory
	    >> Create put /spike_recorder_nodeIDs Set
	    }
	    if

	    K_bg layer_index get population_index get /K_bg_ Set

	    poisson_nodeIDs [layer_index population_index] /poisson_generator <<
	       /rate K_bg_ bg_rate mul
            >> Create put /poisson_nodeIDs Set

	    dc_generator_nodeIDs [layer_index population_index] /dc_generator <<
	       /amplitude K_bg_ dc_amplitude mul
	    >>  Create put /dc_generator_nodeIDs Set

        } for % loop over e and i populations
    } for % loop over layers

    % create and configure thalamic neurons (parrots) and their Poisson inputs
    n_thal 0 gt {
        /parrot_neuron n_thal Create /th_neuron_nodeIDs Set

	/poisson_generator <<
           /rate th_rate
           /start th_start
           /stop th_start th_duration add
        >> Create /th_poisson_nodeID Set

        record {
            /spike_recorder Create <<
	       /record_to /memory
	    >> /th_spike_recorder_nodeID Set
        } if
    } if
} def


% ConnectNetworkNodes - Connect the network nodes created in
% CreateNetworkNodes based on the probabilities defined in
% network_params.sli.
%
/ConnectNetworkNodes
{
    tic

    0 1 n_layers 1 sub { % target layer
        /target_layer Set

        0 1 n_pops_per_layer 1 sub { % target population
	    /target_pop Set

            % get neuron IDs
            neuron_nodeIDs target_layer get target_pop get /target_nodes Set

            n_neurons target_layer get target_pop get /n_targets Set
            full_scale_n_neurons target_layer get target_pop get /full_scale_n_targets Set

	    0 1 n_layers 1 sub { % source layer
	        /source_layer Set

	        0 1 n_pops_per_layer 1 sub { % source population
		    /source_pop Set

		    % local connections

		    % get neuron IDs
                    neuron_nodeIDs source_layer get source_pop get /source_nodes Set

                    n_neurons source_layer get source_pop get /n_sources Set
                    full_scale_n_neurons source_layer get source_pop get /full_scale_n_sources Set

                    % get connection probability
		    conn_probs
		    % pick row (target) in conn_probs
		    target_layer n_pops_per_layer mul target_pop add get
		    % pick column (source) in conn_probs
		    source_layer n_pops_per_layer mul source_pop add get
		    /conn_prob Set % probability for this connection

                    % Compute numbers of synapses assuming binomial degree
                    % distributions and allowing for multapses (see Potjans
                    % and Diesmann 2012 Cereb Cortex Eq. 1)
                    preserve_K {
                        full_scale_n_sources full_scale_n_targets mul /prod Set
                        ( log(1.-conn_prob)/log((prod-1.)/prod) ) ExecMath /n_syn_temp Set
                        n_syn_temp n_targets mul full_scale_n_targets div
                    }{
                        n_sources n_targets mul /prod Set
                        ( log(1.-conn_prob)/log((prod-1.)/prod) ) ExecMath
                    } ifelse
                    cvi /n_synapses Set

                    n_synapses 0 gt {
                        PSC_array target_layer get target_pop get source_layer
                        get source_pop get /mean_weight Set

                        % fill the weight dictionary for Connect and insert it into the synapse dictionary
                        mean_weight 0 gt {
                          syn_dict /weight
                          << /normal << /mean mean_weight /std PSC_sd source_pop get abs >> >> CreateParameter
                          0.0 (inf) cvd redraw
                          put
                        }{
                          syn_dict /weight
                          << /normal << /mean mean_weight /std PSC_sd source_pop get abs >> >> CreateParameter
                          (-inf) cvd 0.0 redraw
                          put
                        } ifelse

			% fill the delay dictionary for Connect and insert it into the synapse dictionary
                        syn_dict /delay
                        << /normal << /mean delays source_pop get /std delays_sd source_pop get abs >> >> CreateParameter
                        0.05 (inf) cvd redraw
                        put

			% fill the connectivity dictionary with the number of synapses to be used
                        conn_dict /N n_synapses put
                        conn_dict /rule /fixed_total_number put

                        % Connect the populations
                        source_nodes target_nodes conn_dict syn_dict Connect

                    } if % n_synapses > 0
	        } for % source population
	    } for % source layer

            n_thal 0 gt
            {
                % connections from thalamic neurons

                C_th target_layer get target_pop get /conn_prob Set

                % Compute numbers of synapses assuming binomial degree
                % distributions and allowing for multapses (see Potjans and
                % Diesmann 2012 Cereb Cortex Eq. 1)
                preserve_K {
                    /prod n_thal full_scale_n_targets mul def
                    ( log(1.-conn_prob)/log((prod-1.)/prod) ) ExecMath /n_syn_temp Set
                    n_syn_temp n_targets mul full_scale_n_targets div
                }{
                    /prod n_thal n_targets mul def
                    ( log(1.-conn_prob)/log((prod-1.)/prod) ) ExecMath
                } ifelse
                cvi /n_synapses Set

                n_synapses 0 gt {
                    % insert the weight Parameter into the synapse dictionary
                    syn_dict /weight
                    << /normal << /mean PSC_ext /std PSC_th_sd abs >> >> CreateParameter
                    0.0 (inf) cvd redraw
                    put

                    % insert the delay dictionary into the synapse dictionary
                    syn_dict /delay
                    << /normal << /mean delay_th /std delay_th_sd abs >> >> CreateParameter
                    0.05 (inf) cvd redraw
                    put

		    % fill the connectivity dictionary with the number of synapses to be used
                    conn_dict /N n_synapses put
                    conn_dict /rule /fixed_total_number put

                    % Connect the thalamus
                    th_neuron_nodeIDs target_nodes conn_dict syn_dict Connect

                } if % n_synapses > 0
            } if % n_thal > 0

            % Connect devices

            % Connect to the spike recorder
            % record from a continuous range of IDs (appropriate for networks without spatial information)
	    record {
	       target_nodes n_neurons_rec_spikes target_layer get target_pop get Take
               spike_recorder_nodeIDs target_layer get target_pop get
               /all_to_all
	       Connect
            } if

            % Connect to the Poisson generators
            poisson_nodeIDs target_layer get target_pop get
            target_nodes
            /all_to_all
            << /weight PSC_ext /delay delays 0 get >>
            Connect

            % Connect to the DC generators
            dc_generator_nodeIDs target_layer get target_pop get
            target_nodes
            /all_to_all
            Connect

        } for % target population
    } for % target layer

    n_thal 0 gt {
        % Connect thalamic poisson_generator to thalamic neurons (parrots)
        th_poisson_nodeID 1 arraystore
        th_neuron_nodeIDs
        Connect
    } if

    record n_thal 0 gt and {
        % Connect thalamic neurons to spike recorder
        th_neuron_nodeIDs
        th_spike_recorder_nodeID 1 arraystore
        Connect
    } if

    toc /ConnectTime Set
} def


% ===================================================================================

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%     	Network parameters		%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% area of network in mm^2; scales numbers of neurons
% use 1 for the full-size network (77,169 neurons)
/area scale def

% whether to use full-scale in-degrees when downscaling the number of neurons
% When preserve_K is false, the full-scale connection probabilities are used.
% Note that this produces different dynamics compared to the original model.
/preserve_K true def

/layers [(L23) (L4) (L5) (L6)] def
/populations [(e) (i)] def

/full_scale_n_neurons
  [[20683   % layer 2/3 e
    5834 ]  % layer 2/3 i
   [21915   % layer 4 e
    5479 ]  % layer 4 i
   [4850    % layer 5 e
    1065 ]  % layer 5 i
   [14395   % layer 6 e
    2948 ]] % layer 6 i
def

% mean EPSP amplitude (mV) for all connections except L4e->L2/3e
/PSP_e .15 def
% mean EPSP amplitude (mv) for L4e->L2/3e connections
% see p. 801 of the paper, second paragraph under 'Model Parameterization',
% and the caption to Supplementary Fig. 7
/PSP_e_23_4 PSP_e 2 mul def
% standard deviation of PSC amplitudes relative to mean PSC amplitudes
/PSC_rel_sd 0.1 def
% IPSP amplitude relative to EPSP amplitude
/g -4. def

% probabilities for >=1 connection between neurons in the given populations
% columns correspond to source populations; rows to target populations
% source      2/3e    2/3i    4e      4i      5e      5i      6e      6i
/conn_probs [[0.1009  0.1689  0.0437  0.0818  0.0323  0.      0.0076  0.    ]
             [0.1346  0.1371  0.0316  0.0515  0.0755  0.      0.0042  0.    ]
             [0.0077  0.0059  0.0497  0.135   0.0067  0.0003  0.0453  0.    ]
             [0.0691  0.0029  0.0794  0.1597  0.0033  0.      0.1057  0.    ]
             [0.1004  0.0622  0.0505  0.0057  0.0831  0.3726  0.0204  0.    ]
             [0.0548  0.0269  0.0257  0.0022  0.06    0.3158  0.0086  0.    ]
             [0.0156  0.0066  0.0211  0.0166  0.0572  0.0197  0.0396  0.2252]
             [0.0364  0.001   0.0034  0.0005  0.0277  0.008   0.0658  0.1443]]
	     def

% mean dendritic delays for excitatory and inhibitory transmission (ms)
/delays [1.5 0.75] def
% standard deviation relative to mean delays
/delay_rel_sd 0.5 def
% connection pattern used in connection calls connecting populations
/conn_dict << /rule /fixed_total_number >> def
% default synapse dictionary
/syn_dict << /synapse_model /static_synapse >> def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%          Single-neuron parameters		%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/neuron_model /iaf_psc_exp def  % neuron model. For PSP-to-PSC conversion to
                                % be correct, synapses should be current-based
                                % with an exponential time course

% Initial conditions for the membrane potential, options are:
% (original): uniform mean and std for all populations
% (optimized): population-specific mean and std, allowing a reduction of the
% initial activity burst in the network
/Vm0_type (original) def        % choose either (original) or (optimized)
Vm0_type (optimized) eq
{
    % optimized
    % mean of initial membrane potential (mV)
    /Vm0_mean [[-68.28   % 2/3e
                -63.16]  % 2/3i
               [-63.33   % 4e
                -63.45]  % 4i
               [-63.11   % 5e
                -61.66]  % 5i
               [-66.72   % 6e
                -61.43]] % 6i
                def
    % std of initial membrane potential (mV)
    /Vm0_std  [[5.36     % 2/3e
                4.57]    % 2/3i
               [4.74     % 4e
                4.94]    % 4i
               [4.94     % 5e
                4.55]    % 5i
               [5.46     % 6e
                4.48]]   % 6i
                def
}{
    % original
    /Vm0_mean -58.0 def
    /Vm0_std 10.0 def
} ifelse

% neuron model parameters
/model_params  << /tau_m 10.        % membrane time constant (ms)
	          /tau_syn_ex 0.5   % excitatory synaptic time constant (ms)
                  /tau_syn_in 0.5   % inhibitory synaptic time constant (ms)
                  /t_ref 2.         % absolute refractory period (ms)
	          /E_L -65.         % resting membrane potential (mV)
	          /V_th -50.        % spike threshold (mV)
             	  /C_m 250.         % membrane capacitance (pF)
	          /V_reset -65.     % reset potential (mV)
               >> def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%           Stimulus parameters		%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% rate of background Poisson input at each external input synapse (spikes/s)
/bg_rate 8. def
% DC amplitude at each external input synapse (pA)
% This is relevant for reproducing Potjans & Diesmann (2012) Fig. 7.
/dc_amplitude 0. def
% in-degrees for background input
/K_bg [[1600   % 2/3e
        1500]  % 2/3i
       [2100   % 4e
        1900]  % 4i
       [2000   % 5e
        1900]  % 5i
       [2900   % 6e
        2100]] % 6i
        def

% optional additional thalamic input (Poisson)
% Set n_thal to 0 to avoid this input.
% For producing Potjans & Diesmann (2012) Fig. 10, n_thal=902 was used.
% Note that the thalamic rate here reproduces the simulation results
% shown in the paper, and differs from the rate given in the text.
/n_thal 0 def          % size of thalamic population
/th_start 700. def     % onset of thalamic input (ms)
/th_duration 10. def   % duration of thalamic input (ms)
/th_rate 120. def      % rate of thalamic neurons (spikes/s)
/PSP_ext 0.15 def      % mean EPSP amplitude (mV) for external input

% connection probabilities for thalamic input
/C_th [[0.0       % 2/3e
        0.0   ]   % 2/3i
       [0.0983    % 4e
        0.0619]   % 4i
       [0.0       % 5e
        0.0   ]   % 5i
       [0.0512    % 6e
        0.0196]]  % 6i
      def

% mean delay of thalamic input (ms)
/delay_th 1.5 def
% standard deviation relative to mean delay of thalamic input
/delay_th_rel_sd 0.5 def

% ===================================================================================


% execute functions
CheckParameters
PrepareSimulation
DerivedParameters
CreateNetworkNodes
ConnectNetworkNodes

t_sim Simulate
toc /SimTime Set

(\n-----------------------------) =
(Simulation report) =
(-----------------------------) =

/ks GetKernelStatus def

(Number of threads: ) =only ks /local_num_threads get =
(Scale            : ) =only scale =
(Network size     : ) =only ks /network_size get =
(Num connections  : ) =only ks /num_connections get =
(Simulated time   : ) =only t_sim =only ( ms) =
(Total spikes     : ) =only ks /local_spike_counter get =
(Population spikes: ) =only
record
{
  spike_recorder_nodeIDs { { /n_events get } Map } Map ==
}
{
  (---) =
}
ifelse
() =
(Time create nodes: ) =only ks /time_construction_create get =only ( s)=
(Time connect     : ) =only ks /time_construction_connect get =only ( s)=
(Time prepare     : ) =only ks /time_communicate_prepare get =only ( s)=
(Time simulate    : ) =only ks /time_simulate get =only ( s)=
(-----------------------------) =
