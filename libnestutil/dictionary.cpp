/*
 *  dictionary.cpp
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "dictionary.h"

#include "kernel_manager.h"

/**
 * General vector streamer.
 * This templated operator streams all elements of a std::vector<>.
 */
template < typename T >
std::ostream&
operator<<( std::ostream& os, const std::vector< T >& vec )
{
  os << "vector[";
  bool first = true;
  for ( const auto& element : vec )
  {
    if ( not first )
    {
      os << ", ";
    }
    os << element;
    first = false;
  }
  return os << "]";
}

any_type&
dictionary::operator[]( const std::string& key ) const
{
  return ( **this )[ key ];
}
any_type&
dictionary::operator[]( std::string&& key ) const
{
  return ( **this )[ std::move( key ) ];
}
any_type&
dictionary::at( const std::string& key )
{
  return ( **this ).at( key );
}
const any_type&
dictionary::at( const std::string& key ) const
{
  return ( **this ).at( key );
}

template <>
double
dictionary_::cast_value_< double >( const any_type& value, const std::string& key ) const
{
  try
  {
    if ( const double* v = std::get_if< double >( &value ) )
    {
      return *v;
    }
    if ( const long* v = std::get_if< long >( &value ) )
    {
      return static_cast< double >( *v );
    }
    if ( const size_t* v = std::get_if< size_t >( &value ) )
    {
      return static_cast< double >( *v );
    }
    if ( const int* v = std::get_if< int >( &value ) )
    {
      return static_cast< double >( *v );
    }
    throw std::bad_variant_access(); // deflect to error handling below
  }
  catch ( const std::bad_variant_access& )
  {
    const std::string msg =
      std::string( "Failed to cast '" ) + key + "' from " + debug_type( value ) + " to type double.";
    throw nest::TypeMismatch( msg );
  }
}

template <>
std::vector< double >
dictionary_::cast_value_< std::vector< double > >( const any_type& value, const std::string& key ) const
{
  // PyNEST passes vector with element type any if and only if it needs to pass
  // and empty vector, because the element type of empty lists cannot be inferred
  // at the Python level. The assertion just double-checks that we never get a
  // non-empty vector-of-any.
  if ( value.type() == typeid( std::vector< boost::any > ) )
  {
    assert( boost::any_cast< std::vector< boost::any > >( value ).empty() );
    return std::vector< double >();
  }

  try
  {
    if ( const std::vector< double >* v = std::get_if< std::vector< double > >( &value ) )
    {
      return *v;
    }
    if ( const std::vector< long >* v = std::get_if< std::vector< long > >( &value ) )
    {
      std::vector< double > res;
      std::copy( v->begin(), v->end(), std::back_inserter( res ) );
      return res;
    }
    throw std::bad_variant_access(); // deflect to error handling below
  }
  catch ( const std::bad_variant_access& )
  {
    const std::string msg =
      std::string( "Failed to cast '" ) + key + "' from " + debug_type( value ) + " to type std::vector<double>.";
    throw nest::TypeMismatch( msg );
  }
}


std::string
debug_type( const any_type& operand )
{
  return std::visit(
    []( auto&& arg )
    {
      using T = std::decay_t< decltype( arg ) >;
      return boost::typeindex::type_id< T >().pretty_name();
    },
    operand );
}

std::string
debug_dict_types( const Dictionary& dict )
{
  std::string s = "[Dictionary]\n";

  for ( auto& kv : dict )
  {
    s += kv.first + ": ";
    s += debug_type( kv.second.item ) + "\n";
  }
  return s;
}

// TODO-PYNEST-NG: Check if we can remove these somehow
std::ostream&
operator<<( std::ostream& os, const std::vector< std::vector< long > >& )
{
  os << "vector<vector<long>>";
  return os;
}
std::ostream&
operator<<( std::ostream& os, const std::vector< std::vector< double > >& )
{
  os << "vector<vector<double>>";
  return os;
}
std::ostream&
operator<<( std::ostream& os, const std::vector< std::vector< std::vector< long > > >& )
{
  os << "vector<vector<vector<long>>>";
  return os;
}
std::ostream&
operator<<( std::ostream& os, const std::vector< std::vector< std::vector< double > > >& )
{
  os << "vector<vector<vector<double>>>";
  return os;
}
std::ostream&
operator<<( std::ostream& os, const std::shared_ptr< nest::Parameter >& )
{
  os << "parameter";
  return os;
}
std::ostream&
operator<<( std::ostream& os, const nest::VerbosityLevel& )
{
  os << "verbosity level";
  return os;
}

std::ostream&
operator<<( std::ostream& os, const Dictionary& dict )
{
  const auto max_key_length = std::max_element( dict.begin(),
    dict.end(),
    []( const dictionary_::value_type s1, const dictionary_::value_type s2 ) {
      return s1.first.length() < s2.first.length();
    } )->first.length();
  const std::string pre_padding = "    ";
  os << "Dictionary{\n";
  for ( auto& kv : dict )
  {
    std::string type;
    std::stringstream value_stream;

    const auto& item = kv.second.item;

    const auto post_padding = max_key_length - kv.first.length() + 5;
    os << pre_padding << kv.first << std::setw( post_padding ) << "(" << debug_type( item ) << ")"
       << " " << std::setw( 25 - type.length() );
    std::visit( [ &os ]( const auto& arg ) { os << arg; }, item );
  }
  return os << "}";
}

bool
value_equal( const any_type& first, const any_type& second )
{
  if ( std::holds_alternative< int >( first ) )
  {
    if ( not std::holds_alternative< int >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< int >( first );
    const auto other_value = std::get< int >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< long >( first ) )
  {
    if ( not std::holds_alternative< long >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< long >( first );
    const auto other_value = std::get< long >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< size_t >( first ) )
  {
    if ( not std::holds_alternative< size_t >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< size_t >( first );
    const auto other_value = std::get< size_t >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< double >( first ) )
  {
    if ( not std::holds_alternative< double >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< double >( first );
    const auto other_value = std::get< double >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< bool >( first ) )
  {
    if ( not std::holds_alternative< bool >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< bool >( first );
    const auto other_value = std::get< bool >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::string >( first ) )
  {
    if ( not std::holds_alternative< std::string >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::string >( first );
    const auto other_value = std::get< std::string >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::vector< int > >( first ) )
  {
    if ( not std::holds_alternative< std::vector< int > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::vector< int > >( first );
    const auto other_value = std::get< std::vector< int > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::vector< double > >( first ) )
  {
    if ( not std::holds_alternative< std::vector< double > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::vector< double > >( first );
    const auto other_value = std::get< std::vector< double > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::vector< std::vector< double > > >( first ) )
  {
    if ( not std::holds_alternative< std::vector< std::vector< double > > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::vector< std::vector< double > > >( first );
    const auto other_value = std::get< std::vector< std::vector< double > > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::vector< std::string > >( first ) )
  {
    if ( not std::holds_alternative< std::vector< std::string > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::vector< std::string > >( first );
    const auto other_value = std::get< std::vector< std::string > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::vector< size_t > >( first ) )
  {
    if ( not std::holds_alternative< std::vector< size_t > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::vector< size_t > >( first );
    const auto other_value = std::get< std::vector< size_t > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< dictionary >( first ) )
  {
    if ( not std::holds_alternative< dictionary >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< dictionary >( first );
    const auto other_value = std::get< dictionary >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else if ( std::holds_alternative< std::shared_ptr< nest::Parameter > >( first ) )
  {
    if ( not std::holds_alternative< std::shared_ptr< nest::Parameter > >( second ) )
    {
      return false;
    }
    const auto this_value = std::get< std::shared_ptr< nest::Parameter > >( first );
    const auto other_value = std::get< std::shared_ptr< nest::Parameter > >( second );
    if ( this_value != other_value )
    {
      return false;
    }
  }
  else
  {
    std::string msg = std::string( "Unsupported type in Dictionary::value_equal(): " ) + debug_type( first );
    throw nest::TypeMismatch( msg );
  }
  return true;
}


bool
dictionary_::operator==( const dictionary_& other ) const
{
  if ( size() != other.size() )
  {
    return false;
  }
  // Iterate elements in the other Dictionary
  for ( const auto& [ other_key, other_entry ] : other )
  {
    // Check if it exists in this Dictionary
    if ( not known( other_key ) )
    {
      return false;
    }

    // Check for equality
    const auto& this_entry = maptype_::at( other_key );
    if ( not value_equal( this_entry.item, other_entry.item ) )
    {
      return false;
    }
  }
  // All elements are equal
  return true;
}

void
dictionary_::register_access_( const DictEntry_& entry ) const
{
  if ( not entry.accessed )
  {
    // if() above avoids any unnecessary updates, atomic prevents any potential
    // data races in case the compiler does behind-the-scences magic.
#pragma omp atomic write
    entry.accessed = true; // accessed is mutable
  }
}

any_type&
dictionary_::operator[]( const std::string& key )
{
  auto& entry = maptype_::operator[]( key );
  // op[] inserts entry if key was not known before, so we are sure entry exists
  register_access_( entry );
  return entry.item;
}

any_type&
dictionary_::operator[]( std::string&& key )
{
  auto& entry = maptype_::operator[]( key );
  // op[] inserts entry if key was not known before, so we are sure entry exists
  register_access_( entry );
  return entry.item;
}

any_type&
dictionary_::at( const std::string& key )
{
  auto& entry = maptype_::at( key );
  // at() throws if key is not know, so we are sure entry exists
  register_access_( entry );
  return entry.item;
}

const any_type&
dictionary_::at( const std::string& key ) const
{
  const auto& entry = maptype_::at( key );
  // at() throws if key is not know, so we are sure entry exists
  register_access_( entry );
  return entry.item;
}

dictionary_::iterator
dictionary_::find( const std::string& key )
{
  const auto it = maptype_::find( key );
  if ( it != end() )
  {
    register_access_( it->second );
  }
  return it;
}

dictionary_::const_iterator
dictionary_::find( const std::string& key ) const
{
  const auto it = maptype_::find( key );
  if ( it != end() )
  {
    register_access_( it->second );
  }
  return it;
}

void
dictionary_::init_access_flags( const bool thread_local_dict ) const
{
  if ( not thread_local_dict )
  {
    nest::kernel().vp_manager.assert_single_threaded();
  }
  for ( const auto& [ key, entry ] : *this )
  {
    entry.accessed = false;
  }
}

void
dictionary_::all_entries_accessed( const std::string& where,
  const std::string& what,
  const bool thread_local_dict ) const
{
  if ( not thread_local_dict )
  {
    nest::kernel().vp_manager.assert_single_threaded();
  }

  // Vector of elements in the dictionary that are not accessed
  std::vector< dictionary_::key_type > not_accessed_keys;

  for ( const auto& [ key, entry ] : *this )
  {
    if ( not entry.accessed )
    {
      not_accessed_keys.emplace_back( key );
    }
  }

  if ( not_accessed_keys.size() > 0 )
  {
    const auto missed = std::accumulate( not_accessed_keys.begin(),
      not_accessed_keys.end(),
      dictionary_::key_type(), // creates empty instance of key type (string)
      []( const dictionary_::key_type& a, const dictionary_::key_type& b ) { return a + " " + b; } );

    throw nest::UnaccessedDictionaryEntry( what, where, missed );
  }
}
