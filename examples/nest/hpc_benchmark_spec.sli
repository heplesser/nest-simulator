/*
 *  hpc_benchmark_spec.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

% autorun=true

/*
   This script produces a balanced random network of scale*11250 neurons in
   which the excitatory-excitatory neurons exhibit STDP with
   multiplicative depression and power-law potentiation. A mutual
   equilibrium is obtained between the activity dynamics (low rate in
   asynchronous irregular regime) and the synaptic weight distribution
   (unimodal). The number of incoming connections per neuron is fixed
   and independent of network size (indegree=11250).

   This is the standard network investigated in:
   Morrison et al (2007). Spike-timing-dependent plasticity in balanced random
     networks. Neural Comput 19(6):1437-67
   Helias et al (2012). Supercomputers ready for use as discovery machines for
     neuroscience. Front. Neuroinform. 6:26
   Kunkel et al (2014). Spiking network simulation code for petascale
     computers. Front. Neuroinform. 8:78


   The difference between this script and hpc_benchmark_2_16.sli is that this
   version is invariant under mpi/thread splits. This affects
     - Randomization of the membrane potential (here it is based on the virtual
       processes)
     - Neurons that are being recorded from (here we always record from the
       first Nrec neurons).


   A note on scaling
   -----------------

   This benchmark was originally developed for very large-scale simulations on
   supercomputers with more than 1 million neurons in the network and
   11.250 incoming synapses per neuron. For such large networks, synaptic input
   to a single neuron will be little correlated across inputs and network
   activity will remain stable over long periods of time.

   The original network size corresponds to a scale parameter of 100 or more.
   In order to make it possible to test this benchmark script on desktop
   computers, the scale parameter is set to 1 below, while the number of
   11.250 incoming synapses per neuron is retained. In this limit, correlations
   in input to neurons are large and will lead to increasing synaptic weights.
   Over time, network dynamics will therefore become unstable and all neurons
   in the network will fire in synchrony, leading to extremely slow simulation
   speeds.

   Therefore, the presimulation time is reduced to 50 ms below and the
   simulation time to 250 ms, while we usually use 100 ms presimulation and
   1000 ms simulation time.

   For meaningful use of this benchmark, you should use a scale > 10 and check
   that the firing rate reported at the end of the benchmark is below 10 spikes
   per second.

  ----------------------------------------------------------------------

   hpc_benchmark.sli: Version modified for SPEC CPU benchmark
    	 - Number of threads can be set on command line
	 - Model scale can be set on command line
	 - Random seed can be set
	 - Total spike count, timers and som more stats reported in *.rpt file
	 - Entirely self-contained, does not depend on external files
	 - Assumes being run on a single MPI process
	 - No spike recorders, only use local spike counter
	 - No output to *.log files
	 - Presimulation and simulation run by single call to Simulate

    Configuration via colon-separated user arguments, where all arguments are optional

    nest --userargs=threads=T:scale=S:seed=R hpc_benchmark_spec.sli

    e.g.

    nest --userargs=threads=4:scale=0.4:seed=12 hpc_benchmark_spec.sli

    Note: Because NEST uses bitfields of limited size in spike communication, only about
          134 million connections can be handled on a single thread. Therefore, scale
	  must not be larger than 1 for a single thread. If more connections are needed,
	  increase NUM_BITS_LCID in nest_types.h and reduce other NUM_BITS_* correspondingly.

    Note: Changing the number of threads for fixed scale will lead to changes in "Total spikes" comparable
	  to the differences observed for different seeds, since random numbers are distributed differently.

	  Compiling with different compilers (specifically C++ standard libraries with different non-uniform
	  random number algorithms) will lead to similar changes in "Total spikes".

	  Different implementations of the exp() or expm1() function in different glibc() or hardware architectures
	  may also lead to different "Total spike" values, see

	      Blanco, W., Lopes, P. H., De S. Souza, A. A., & Mascagni, M. (2020).
	      Non-replicability circumstances in a neural network model with Hodgkin-Huxley-type neurons.
	      Journal of Computational Neuroscience, 48(3), 357-363. https://doi.org/10.1007/s10827-020-00748-3

*/

M_INFO setverbosity

% ************************************************************************** %
%                                                                            %
% Parse command line                                                         %
%                                                                            %
% ************************************************************************** %

/n_threads 1 def
/scale 1 def
/rng_seed 12345 def
/record true def

/reportfile (hpc_benchmark_spec.rpt) def

statusdict /userargs get { (=) breakup } Map
{
 arrayload ;
 /val Set /key Set

 mark
 key (threads) eq { /n_threads val cvi def } case
 key (scale) eq { /scale val cvd def } case
 key (seed) eq { /rng_seed val cvi def } case
 { /hpc_benchmark_spec (Unknown option: ") key join (") join cvlit raiseerror }
 switchdefault
}
forall


%%%%%%%%%%%%%%%%%%%%%%%%% PARAMETER SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% define all relevant parameters: changes should be made here
% all data is placed in the userdict dictionary

/nvp n_threads def              % total number of virtual processes
/simtime 250. def       % total simulation time in ms
/presimtime 50. ms def  % simulation time until reaching equilibrium
/t_sim presimtime simtime add def
/dt 0.1 ms def          % simulation step

% -----------------------------------------------------------------------------

%%%%%%%%% Define function to convert synapse weight from  mV to pA %%%%%%%%%%%

/ConvertSynapseWeight
{
  /tauMem Set
  /tauSyn Set
  /CMem Set
  % This function is specific to the used neuron model
  % Leaky integrate-and-fire neuron with alpha-shaped
  % postsynaptic currents
  (
    % compute time to maximum of V_m after spike input to neuron at rest
    a = tauMem / tauSyn;
    b = 1.0 / tauSyn - 1.0 / tauMem;
    t_rise = 1.0/b * (-LambertWm1(-exp(-1.0/a)/a)-1.0/a);

    % maximum of PSP for current of unit amplitude
    exp(1.0)/(tauSyn*CMem*b) * ((exp(-t_rise/tauMem) - exp(-t_rise/tauSyn)) / b - t_rise*exp(-t_rise/tauSyn))
  ) ExecMath
  1 exch div
}
def

% For compatiblity with earlier benchmarks, we require a rise time of
% t_rise = 1.700759 ms and we choose tau_syn to achieve this for given
% tau_m. This requires numerical inversion of the expression for t_rise
% in ConvertSynapseWeight. We computed this value once and hard-code
% it here.

/tau_syn 0.32582722403722841 ms def

% -----------------------------------------------------------------------------

/brunel_params
<<
  /NE 9000 scale mul round cvi   % number of excitatory neurons
  /NI 2250 scale mul round cvi   % number of inhibitory neurons

  /model_params
  <<
    % Set variables for iaf_psc_alpha
    /E_L     0.0  mV  % Resting membrane potential (mV)
    /C_m   250.0  pF  % Capacity of the membrane (pF)
    /tau_m  10.0  ms  % Membrane time constant (ms)
    /t_ref   0.5  ms  % duration of refractory period (ms)
    /V_th   20.0  mV  % Threshold (mV)
    /V_reset 0.0  mV  % Reset Potential (mV)
    /tau_syn_ex   tau_syn % time const. postsynaptic excitatory currents (ms)
    /tau_syn_in   tau_syn % time const. postsynaptic inhibitory currents (ms)
    /tau_minus 30.0 ms %time constant for STDP (depression)
    % V can be randomly initialized see below
    /V_m 5.7 mV % mean value of membrane potential
  >>

  /randomize_Vm true
  /mean_potential 5.7 mV  % Note that Kunkel et al. (2014) report different values. The values
  /sigma_potential 7.2 mV % in the paper were used for the benchmarks on K, the values given
                          % here were used for the benchmark on JUQUEEN.

  /delay 1.5 ms           % synaptic delay, all connections (ms)

   % synaptic weight
  /JE 0.14 mV             % peak of EPSP

  /sigma_w 3.47 pA        % standard dev. of E->E synapses (pA)
  /g  -5.0

  /stdp_params
  <<
    /delay 1.5 ms
    /alpha  0.0513
    /lambda 0.1           % STDP step size
    /mu     0.4           % STDP weight dependence exponent (potentiation)
    /tau_plus 15.0        % time constant for potentiation
  >>

  /eta 1.685              % scaling of external stimulus

>> def

% Here we resolve parameter dependencies, by making the independent
% values visible
brunel_params dup using

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% FUNCTION SECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/BuildNetwork
{

  % set global kernel parameters
  <<
     /total_num_virtual_procs nvp
     /rng_seed rng_seed
     /resolution  dt
     /overwrite_files true
  >> SetKernelStatus

  %------------------------- Creation -----------------------------------------

  /iaf_psc_alpha    model_params    SetDefaults

  /E_neurons /iaf_psc_alpha NE Create def

  /I_neurons /iaf_psc_alpha NI Create def

  randomize_Vm
  {
      /potential_param << /normal << /mean mean_potential /std sigma_potential >> >> CreateParameter def
      E_neurons LocalOnly << /V_m potential_param >> SetStatus
      I_neurons LocalOnly << /V_m potential_param >> SetStatus
  } if

  /CE NE scale cvd div iround def % number of incoming excitatory connections
  /CI NI scale cvd div iround def % number of incoming inhibitory connections

  model_params using

  % Convert synapse weight from mV to pA
  C_m tau_syn tau_m ConvertSynapseWeight /conversion_factor Set
  /JE_pA conversion_factor JE mul def

  /nu_thresh V_th CE tau_m C_m div mul JE_pA mul 1.0 exp mul tau_syn mul div def
  /nu_ext nu_thresh eta mul def
  endusing

  /E_stimulus /poisson_generator Create def
  E_stimulus
  <<
     /rate nu_ext CE mul 1000. mul
  >> SetStatus

  % Create custom synapse types with appropriate values for
  % our excitatory and inhibitory connections
  /static_synapse_hpc << /delay delay >> SetDefaults
  /static_synapse_hpc /syn_std  CopyModel
  /static_synapse_hpc /syn_ex << /weight JE_pA >> CopyModel
  /static_synapse_hpc /syn_in << /weight JE_pA g mul >> CopyModel

  stdp_params /weight JE_pA put
  /stdp_pl_synapse_hom_hpc stdp_params SetDefaults

 %------------------------- Connection -----------------------------------------


  % Connect Poisson generator to neuron
  E_stimulus E_neurons << /rule (all_to_all) >> << /synapse_model /syn_ex >> Connect
  E_stimulus I_neurons << /rule (all_to_all) >> << /synapse_model /syn_ex >> Connect

  E_neurons E_neurons << /rule (fixed_indegree) /indegree CE /allow_autapses false /allow_multapses true >>
                      << /synapse_model /stdp_pl_synapse_hom_hpc >> Connect

  I_neurons E_neurons << /rule (fixed_indegree) /indegree CI /allow_autapses false /allow_multapses true >>
                      << /synapse_model /syn_in >> Connect

  E_neurons I_neurons << /rule (fixed_indegree) /indegree CE /allow_autapses false /allow_multapses true >>
                      << /synapse_model /syn_ex >> Connect

  I_neurons I_neurons << /rule (fixed_indegree) /indegree CI /allow_autapses false /allow_multapses true >>
                      << /synapse_model /syn_in >> Connect

 } def % end of buildnetwork

%-------------------------- Simulation -----------------------------------------

/RunSimulation
{
  ResetKernel

  BuildNetwork

  t_sim Simulate
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RUN BENCHMARK %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

RunSimulation

  /ks GetKernelStatus def

  reportfile (w) file

  (Number of threads: ) <- ks /local_num_threads get <- endl
  (Scale            : ) <- scale <- endl
  (Random seed      : ) <- ks /rng_seed get <- endl
  (Network size     : ) <- ks /network_size get <- endl
  (Num connections  : ) <- ks /num_connections get <- endl
  (Simulated time   : ) <- t_sim <- ( ms) <- endl
  (Total spikes     : ) <- ks /local_spike_counter get <- endl
  (Average rate     : ) <- ks /local_spike_counter get cvd NE NI add cvd div t_sim div 1000 mul <- ( sp/s) <- endl

  endl
  (Time create nodes: ) <- ks /time_construction_create get <- ( s) <- endl
  (Time connect     : ) <- ks /time_construction_connect get <- ( s) <- endl
  (Time prepare     : ) <- ks /time_communicate_prepare get <- ( s) <- endl
  (Time simulate    : ) <- ks /time_simulate get <- ( s) <- endl

  close

  (\nReport written to: ) =only reportfile =
  () =
